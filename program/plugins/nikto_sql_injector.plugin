#VERSION,2.00
###############################################################################
#  Copyright (C) 2016 Jonathan Mitchell
#
#  This program is free software; you can redistribute it and/or
#  modify it under the terms of the GNU General Public License
#  as published by the Free Software Foundation; version 2
#  of the License only.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to
#  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
###############################################################################
# PURPOSE:
# Look for sql injection  based on manupulating url parameters
###############################################################################
sub nikto_sql_injector_init {
    my $id = { name        => "sql_injector",
               full_name   => "sql injector",
               author      => "jonathan",
               description => "Look for sql injection",
               hooks       => { scan => {method => \&nikto_sql_injector,},},
               options     => { url => "full url with parameters to inject", },
               copyright   => "2016 jonathan",
    };

    return $id;
}

sub nikto_sql_injector {
	use URI;
    use URI::QueryParam;
    

    my ($mark, $parameters) = @_;
    my ($found, @urls,);
    my (%flags, %files);

    # these are examples from my 'classification section'
    $sql_injections{'tautology'} = "1' OR 1=1";
    $sql_injections{'illegal'} = "1' AND 2=9";
    $sql_injections{'union'} = "1' UNION ALL SELECT user_email from wp_users";
    $sql_injections{'piggy'} = "1'; select user_email from wp_users";

    $flags{'nohost'} = 1;
    
    # process the queries, re-making them with injecions
    foreach my $injection (values %sql_injections) {
    	
    	# create another object with the original url
		my $uri = URI->new( $parameters->{'url'} );
		
		#loop and replace each query with the injected version
		foreach my $key ($uri->query_param) {
            
            #clone the original uri
            $new_uri = $uri->clone;
            #update the parameter with the new injected version
            $new_uri->query_param($key, $injection);
            print $new_uri->query."\n";
	        # store it as the key in the url array
	        $urls{ "?".$new_uri->query } = 1;
		}

    }

    
    

    foreach my $uri (keys %urls) {
        return if $mark->{'terminate'};

        # request by hostname
        my ($res, $content, $error, $request, $response) = nfetch($mark, $uri, "GET", "", "", "", "sql_injector");


        if ($res eq "200") {
                if (($content =~ /error in your SQL syntax/)) {
                      print "\n".'sql injection found:'."\n"."$uri";
                      # Looks like a match - raise this up to the front end
                      add_vulnerability(
                            $mark,                   # mark structure to identify target
                            "SQL Injection found", # message
                            400001,             # tid
                            0,                       # OSVDB reference
                            $uri,                    # URI
                            $request,                # Request structure for full output
                            $response);              # Response structure for full output
               }
        }
    }
}

1;
